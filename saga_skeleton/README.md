# Saga pattern

- 약관의 일관성을 포기하고 Eventual Consistency(최종 일관성)을 보장하여 효율성을 높이는 패턴
- 2PC에서는 하나의 트랜잭션으로 처리했던 작업을 여러 트랜잭션으로 분리하여 처리
- 트랜잭션의 원자성을 지켜주기 위해 보상 트랜잭션(Compensation Transaction)을 사용
  - 보상 트랜잭션은 트랜잭션 일부가 실패한 경우 `이전에 성공한 트랜잭션을 되돌리는 역할`
  - 보상 트랜잭션 또한 실패할 수 있기에 이에대한 대비 또한 필요
- 각 트랜잭션은 독립적으로 실행되고 다음 트랜잭션을 호출하는 메시지나 이벤트를 생성

## Choreography Saga Pattern

- 각 서비스끼리 이벤트를 주고받는 방식
- 각 서비스가 다른 서비스의 로컬 트랜잭션을 트리거하는 방식으로 동작
- 중앙집중 된 지점없이 `메시지 브로커`를 통해 이벤트를 pub/sub하는 방식
  - 단일 실패지점(Single Point of Failure, SPOF)이 없음
- 단점
  - 서비스끼리 이벤트를 주고 받기 때문에 큰 시스템의 경우 구조 파악이 어려울 수 있음
  - 트랜잭션을 시뮬레이션하기 위해 모든 서비스를 실행해야하므로 테스트와 디버깅이 어려움

## Orchestration Saga Pattern

- Saga를 관리하는 중앙 서비스가 존재
- 각 서비스는 중앙 서비스에게 요청을 보내고 중앙 서비스는 각 서비스에게 요청을 보내는 방식
- 중앙 서비스는 각 서비스의 상태를 추적하고 보상 트랜잭션을 호출
  - Orchestrator가 각 서비스의 상태를 확인하고 보상 트랜잭션을 실행
- 많은 서비스가 있는 복잡한 워크플로우에 적합
- 단점
  - 중앙 서비스가 SPOF가 될 수 있음
  - 중앙 서비스가 복잡해질수록 유지보수가 어려워질 수 있음